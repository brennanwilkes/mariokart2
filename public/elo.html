<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Elo History</title>
  <meta name="viewport" content="width=device-width,initial-scale=1">
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css" rel="stylesheet">
  <link rel="stylesheet" href="css/style.css">
  <script src="https://code.jquery.com/jquery-3.7.1.min.js"></script>
  <style>
    /* simple greying for disabled smoothing bar */
    input[type=range][disabled] {
      opacity: .35;
      pointer-events: none;
    }
  </style>
</head>

<body class="p-3 chart-page">
  <!-- navigation -->
  <header class="site-nav mb-3">
    <nav class="nav nav-pills flex-sm-row justify-content-center">
      <a class="flex-sm-fill text-sm-center nav-link" href="/">ğŸ New Race</a>
      <a class="flex-sm-fill text-sm-center nav-link active" href="/elo">ğŸ“ˆ Elo Chart</a>
    </nav>
  </header>

  <!-- controls -->
  <header class="mb-3">
    <div class="row g-3">
      <div class="col-12 col-md-6 d-flex justify-content-center align-items-center gap-2">
        <label class="form-label m-0">Smoothing</label>
        <!-- disabled & greyed-out -->
        <input type="range" id="smooth" class="form-range flex-grow-1"
               min="0" max="4" step="1" value="0" disabled style="max-width:220px">
        <span id="smoothVal" class="badge bg-secondary">0</span>
      </div>
      <div class="col-12 col-md-6 d-flex justify-content-center align-items-center gap-2">
        <div class="form-check">
          <input class="form-check-input" type="checkbox" id="uncertainty">
          <label class="form-check-label" for="uncertainty">Show uncertainty</label>
        </div>
      </div>
    </div>
  </header>

  <!-- chart -->
  <div class="chart-wrapper">
    <canvas id="chart"></canvas>
  </div>

  <!-- libs -->
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/chartjs-chart-error-bars@4.4.4/build/index.umd.min.js"></script>

  <script>
    /* â”€â”€â”€ constants â”€â”€â”€ */
    const START_MU      = 900;
    const START_SIGMA   = 100;
    const SMOOTH_VALUES = [0, 2, 5, 10, 25];
    const GOLD          = '#FFD700';

    /* horizontal 1000 guide */
    const hardCpuLine = {
      id:'hardCpuLine',
      afterDraw({ctx,chartArea:{left,right},scales:{y}}){
        const yPos=y.getPixelForValue(1000);
        ctx.save();
        ctx.strokeStyle='#000';          // solid black, full opacity
        ctx.setLineDash([4,4]);
        ctx.beginPath(); ctx.moveTo(left,yPos); ctx.lineTo(right,yPos); ctx.stroke();
        ctx.setLineDash([]);

        const txt='Hard CPU', pad=4, f=12;
        ctx.font=`${f}px sans-serif`;
        const w=ctx.measureText(txt).width+pad*2, h=f+pad*2;
        const x=left+8;                  // label on LEFT
        const yBox=yPos-h/2;
        ctx.fillStyle='#fff'; ctx.fillRect(x,yBox,w,h);
        ctx.fillStyle='#000'; ctx.textBaseline='middle';
        ctx.fillText(txt,x+pad,yPos);
        ctx.restore();
      }
    };
    Chart.register(hardCpuLine);

    let rawData, chart;

    /* trailing-window mean */
    const smooth=(arr,w)=>w
      ? arr.map((_,i)=>arr.slice(Math.max(0,i-w+1),i+1)
                         .reduce((a,b)=>a+b,0)/Math.min(w,i+1))
      : arr;

    const rebuild=()=>{
      const prevVis = chart
        ? Object.fromEntries(chart.data.datasets.map((d,i)=>[d.label,chart.isDatasetVisible(i)]))
        : {};

      const winSize = SMOOTH_VALUES[+$('#smooth').val()];
      const showUnc = $('#uncertainty').prop('checked');

      /* one date label per day */
      const seen=new Set();
      const labels=rawData.labels.map(l=>{
        if(!l) return '';
        const d=new Date(l), key=d.toISOString().slice(0,10);
        if(seen.has(key)) return '';
        seen.add(key);
        return d.toLocaleDateString(undefined,{month:'short',day:'numeric'});
      });

      const sets=[];
      rawData.datasets.forEach(ds=>{
        const muSm=smooth(ds.muRaw,winSize);

        const baseData=[], winData=[];
        muSm.forEach((m,i)=>{
          const pos   = ds.pos[i];
          const raced = pos!==null;
          const won   = pos===1;
          const point={y:m};
          if(raced && showUnc){
            const s=ds.sigma[i];
            point.yMin=m-s; point.yMax=m+s;
          }
          baseData.push(point);
          if(won) winData.push({x:i,y:m});
        });

        const playedLast = ds.pos.at(-1)!==null;

        /* main line */
        sets.push({
          label : ds.label,
          data  : baseData,
          hidden: prevVis.hasOwnProperty(ds.label)?!prevVis[ds.label]:!playedLast,
          borderColor:ds.color,
          backgroundColor:ds.color,
          errorBarColor:ds.color,
          errorBarWhiskerColor:ds.color,
          errorBarStrokeStyle:ds.color,
          errorBarLineWidth:showUnc?1:0,
          errorBarWhiskerLineWidth:showUnc?1:0,
          tension:0.3,
          borderWidth:2,
          pointRadius: i=>ds.pos[i.dataIndex]===null?0:3,
          pointStyle: i=>ds.pos[i.dataIndex]===null?false:'circle',
          pointBackgroundColor:ds.color,
          pointBorderColor:ds.color,
          pointBorderWidth:1,
          order:0
        });

        /* winner overlay */
        if(winData.length){
          sets.push({
            label:'_'+ds.label+'_wins',
            data:winData,
            type:'scatter',
            showLine:false,
            parsing:false,
            pointRadius:6,
            pointStyle:'circle',
            pointBackgroundColor:'#fff',
            pointBorderColor:GOLD,
            pointBorderWidth:4,
            order:99,
            hidden:sets[sets.length-1].hidden,
            borderColor:'#0000',
            backgroundColor:'#0000'
          });
        }
      });

      if(chart) chart.destroy();
      chart=new Chart(document.getElementById('chart'),{
        type:'lineWithErrorBars',
        data:{labels,datasets:sets},
        options:{
          responsive:true,
          maintainAspectRatio:false,
          interaction:{mode:'index',intersect:false},
          layout:{padding:{right:16}},
          plugins:{
            legend:{
              labels:{
                filter:item=>!item.text.startsWith('_')
              },
              onClick:(evt,item,legend)=>{
                const c=legend.chart, i=item.datasetIndex;
                const label=c.data.datasets[i].label;
                const newVis=!c.isDatasetVisible(i);
                c.setDatasetVisibility(i,newVis);
                const winIdx=c.data.datasets.findIndex(d=>d.label==='_'+label+'_wins');
                if(winIdx!==-1) c.setDatasetVisibility(winIdx,newVis);
                c.update();
              }
            }
          }
        },
        plugins:[hardCpuLine]
      });

      $('#smoothVal').text(winSize);
    };

    /* initial load */
    $.getJSON('/api/elo',data=>{
      data.labels.unshift('');
      data.datasets.forEach(d=>{
        d.mu.unshift(START_MU);
        d.sigma.unshift(START_SIGMA);
        d.muRaw=[...d.mu];
        d.pos=[null,...d.pos];
      });
      rawData=data;
      rebuild();
    });

    $('#smooth').on('input change',rebuild);
    $('#uncertainty').on('change',rebuild);
  </script>
</body>
</html>
